
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Convict3d/mcp-go/client/client.go (56.8%)</option>
				
				<option value="file1">github.com/Convict3d/mcp-go/examples/basic/main.go (0.0%)</option>
				
				<option value="file2">github.com/Convict3d/mcp-go/examples/playwright-http-real/main.go (0.0%)</option>
				
				<option value="file3">github.com/Convict3d/mcp-go/transport/http/http.go (91.0%)</option>
				
				<option value="file4">github.com/Convict3d/mcp-go/transport/stdio/stdio.go (54.9%)</option>
				
				<option value="file5">github.com/Convict3d/mcp-go/types/base.go (78.0%)</option>
				
				<option value="file6">github.com/Convict3d/mcp-go/types/tools.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package client provides a high-level MCP client implementation
package client

import (
        "context"
        "time"

        "github.com/Convict3d/mcp-go/transport"
        "github.com/Convict3d/mcp-go/types"
)

// Client represents a high-level MCP client
type Client struct {
        transport    transport.Transport
        ctx          context.Context
        config       *Config
        serverInfo   *types.Implementation
        capabilities *types.ServerCapabilities
}

// Config holds configuration for the MCP client
type Config struct {
        ServerURL     string
        ClientName    string
        ClientVersion string
        Timeout       time.Duration
        CustomHeaders map[string]string
        Transport     transport.Transport // Custom transport
}

// Option defines a function that configures the client
type Option func(*Config)

// WithClientInfo sets the client name and version
func WithClientInfo(name, version string) Option <span class="cov5" title="4">{
        return func(c *Config) </span><span class="cov5" title="4">{
                c.ClientName = name
                c.ClientVersion = version
        }</span>
}

// WithTimeout sets the request timeout
func WithTimeout(timeout time.Duration) Option <span class="cov3" title="2">{
        return func(c *Config) </span><span class="cov3" title="2">{
                c.Timeout = timeout
        }</span>
}

// WithTransport sets a custom transport
func WithTransport(t transport.Transport) Option <span class="cov8" title="10">{
        return func(c *Config) </span><span class="cov8" title="10">{
                c.Transport = t
        }</span>
}

// WithContext sets a custom context (advanced usage)
func WithContext(ctx context.Context) Option <span class="cov0" title="0">{
        return func(c *Config) </span>{<span class="cov0" title="0">
                // Store context in config for later use in NewClient
                // We'll handle this in the client creation
        }</span>
}

// defaultConfig returns a default client configuration
func defaultConfig() *Config <span class="cov10" title="17">{
        return &amp;Config{
                ClientName:    "go-mcp-client",
                ClientVersion: "1.0.0",
                Timeout:       30 * time.Second,
                CustomHeaders: map[string]string{
                        "Accept": "application/json, text/event-stream",
                },
        }
}</span>

// NewClient creates a new high-level MCP client with options
func NewClient(opts ...Option) *Client <span class="cov9" title="13">{
        config := defaultConfig()

        // Apply all options
        for _, opt := range opts </span><span class="cov9" title="13">{
                opt(config)
        }</span>

        <span class="cov9" title="13">return &amp;Client{
                transport: config.Transport,
                ctx:       context.Background(),
                config:    config,
        }</span>
}

// NewSimpleClient creates a client with minimal configuration for quick setup
func NewSimpleClient() *Client <span class="cov1" title="1">{
        return NewClient()
}</span>

// Initialize connects to the MCP server and performs the handshake
func (c *Client) Initialize(protocolVersion string) error <span class="cov1" title="1">{
        params := struct {
                ProtocolVersion string                   `json:"protocolVersion"`
                Capabilities    types.ClientCapabilities `json:"capabilities"`
                ClientInfo      types.Implementation     `json:"clientInfo"`
        }{
                ProtocolVersion: protocolVersion,
                Capabilities:    types.ClientCapabilities{},
                ClientInfo: types.Implementation{
                        Name:    c.config.ClientName,
                        Version: c.config.ClientVersion,
                },
        }

        var result types.InitializeResult
        err := c.transport.Call(c.ctx, &amp;result, "initialize", params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">c.serverInfo = &amp;result.ServerInfo
        c.capabilities = &amp;result.Capabilities

        // Note: Some MCP servers don't require the initialized notification
        // If needed, uncomment the following lines:
        // var empty interface{}
        // return c.transport.Call(c.ctx, &amp;empty, "initialized", struct{}{})

        return nil</span>
}

// GetServerInfo returns information about the connected server
func (c *Client) GetServerInfo() *types.Implementation <span class="cov3" title="2">{
        return c.serverInfo
}</span>

// GetCapabilities returns the server's capabilities
func (c *Client) GetCapabilities() *types.ServerCapabilities <span class="cov3" title="2">{
        return c.capabilities
}</span>

// GetSessionID returns the current session ID
func (c *Client) GetSessionID() string <span class="cov0" title="0">{
        return c.transport.GetSessionID()
}</span>

// HasTools returns true if the server supports tools
func (c *Client) HasTools() bool <span class="cov6" title="6">{
        return c.capabilities != nil &amp;&amp; c.capabilities.Tools != nil
}</span>

// HasResources returns true if the server supports resources
func (c *Client) HasResources() bool <span class="cov5" title="4">{
        return c.capabilities != nil &amp;&amp; c.capabilities.Resources != nil
}</span>

// HasPrompts returns true if the server supports prompts
func (c *Client) HasPrompts() bool <span class="cov4" title="3">{
        return c.capabilities != nil &amp;&amp; c.capabilities.Prompts != nil
}</span>

// ListTools retrieves the list of available tools from the server
func (c *Client) ListTools() ([]types.Tool, error) <span class="cov1" title="1">{
        if !c.HasTools() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">var result types.ListToolsResult
        err := c.transport.Call(c.ctx, &amp;result, "tools/list")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result.Tools, nil</span>
}

// CallTool executes a tool with the given arguments
func (c *Client) CallTool(name string, arguments map[string]interface{}) (*types.CallToolResult, error) <span class="cov1" title="1">{
        if !c.HasTools() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">params := struct {
                Name      string                 `json:"name"`
                Arguments map[string]interface{} `json:"arguments,omitempty"`
                Meta      types.Meta             `json:"_meta,omitempty"`
        }{
                Name:      name,
                Arguments: arguments,
        }

        var result types.CallToolResult
        err := c.transport.Call(c.ctx, &amp;result, "tools/call", params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;result, nil</span>
}

// ListResources retrieves the list of available resources from the server
func (c *Client) ListResources() ([]types.Resource, error) <span class="cov1" title="1">{
        if !c.HasResources() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">var result types.ListResourcesResult
        err := c.transport.Call(c.ctx, &amp;result, "resources/list")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result.Resources, nil</span>
}

// ReadResource reads the content of a specific resource
func (c *Client) ReadResource(uri string) (*types.ReadResourceResult, error) <span class="cov0" title="0">{
        if !c.HasResources() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">params := struct {
                URI  string     `json:"uri"`
                Meta types.Meta `json:"_meta,omitempty"`
        }{
                URI: uri,
        }

        var result types.ReadResourceResult
        err := c.transport.Call(c.ctx, &amp;result, "resources/read", params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// ListPrompts retrieves the list of available prompts from the server
func (c *Client) ListPrompts() ([]types.Prompt, error) <span class="cov0" title="0">{
        if !c.HasPrompts() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var result types.ListPromptsResult
        err := c.transport.Call(c.ctx, &amp;result, "prompts/list")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result.Prompts, nil</span>
}

// GetPrompt retrieves a specific prompt with arguments
func (c *Client) GetPrompt(name string, arguments map[string]string) (*types.GetPromptResult, error) <span class="cov0" title="0">{
        if !c.HasPrompts() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">params := struct {
                Name      string            `json:"name"`
                Arguments map[string]string `json:"arguments,omitempty"`
                Meta      types.Meta        `json:"_meta,omitempty"`
        }{
                Name:      name,
                Arguments: arguments,
        }

        var result types.GetPromptResult
        err := c.transport.Call(c.ctx, &amp;result, "prompts/get", params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// Close closes the client and cleans up resources
func (c *Client) Close() error <span class="cov7" title="9">{
        return c.transport.Close()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "time"

        "github.com/Convict3d/mcp-go/client"
        "github.com/Convict3d/mcp-go/transport/http"
        "github.com/Convict3d/mcp-go/types"
)

func main() <span class="cov0" title="0">{
        fmt.Println("üöÄ MCP Go Client Library - Professional Example")
        fmt.Println("==============================================")

        transport := http.NewHTTPTransport("http://localhost:9831/mcp",
                http.WithTimeout(30*time.Second),
                http.WithHeader("Accept", "application/json, text/event-stream"),
        )

        // Create the MCP client using option pattern
        c := client.NewClient(
                client.WithTransport(transport),
                client.WithClientInfo("professional-example", "1.0.0"),
        )

        // Initialize connection
        fmt.Println("\nüì° Connecting to MCP server...")
        err := c.Initialize(types.LatestProtocolVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize: %v", err)
        }</span>

        // Get server info
        <span class="cov0" title="0">serverInfo := c.GetServerInfo()
        if serverInfo != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Connected to: %s v%s\n", serverInfo.Name, serverInfo.Version)
        }</span>

        // Get server capabilities
        <span class="cov0" title="0">fmt.Printf("üîß Server capabilities:\n")
        fmt.Printf("   Tools: %v\n", c.HasTools())
        fmt.Printf("   Resources: %v\n", c.HasResources())
        fmt.Printf("   Prompts: %v\n", c.HasPrompts())
        fmt.Printf("   Session ID: %s\n", c.GetSessionID())

        // List and call tools if available
        if c.HasTools() </span><span class="cov0" title="0">{
                fmt.Println("\nüõ†Ô∏è  Listing tools...")
                tools, err := c.ListTools()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to list tools: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Found %d tools:\n", len(tools))
                        for i, tool := range tools </span><span class="cov0" title="0">{
                                fmt.Printf("   %d. %s - %s (%+v)\n", i+1, tool.Name, tool.Description, tool.OutputSchema)
                        }</span>

                        // Try calling a tool if available
                        <span class="cov0" title="0">if len(tools) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\nüéØ Calling tool: %s\n", "browser_navigate")

                                // Example tool call - adjust arguments based on your server
                                result, err := c.CallTool("browser_navigate", map[string]interface{}{
                                        "url": "https://facebook.com",
                                })

                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Tool call failed: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚úÖ Tool executed successfully!\n")
                                        if result.IsError </span><span class="cov0" title="0">{
                                                fmt.Printf("‚ö†Ô∏è  Tool returned an error\n")
                                        }</span>
                                        <span class="cov0" title="0">if len(result.Content) &gt; 0 </span><span class="cov0" title="0">{
                                                contentType := result.GetContentType()
                                                fmt.Printf("üìÑ Content type: %s\n", contentType)

                                                switch contentType </span>{
                                                case "text":<span class="cov0" title="0">
                                                        textContents := result.GetTextContent()
                                                        if len(textContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                fmt.Printf("üìÑ Tool output: %s\n", textContents[0].Text)
                                                        }</span>
                                                case "image":<span class="cov0" title="0">
                                                        imageContents := result.GetImageContent()
                                                        if len(imageContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                fmt.Printf("üìÑ Image output: %s (%s)\n", imageContents[0].MimeType, "data available")
                                                        }</span>
                                                default:<span class="cov0" title="0">
                                                        fmt.Printf("üìÑ Tool output available (%d items)\n", len(result.Content))</span>
                                                }
                                        }
                                }

                                <span class="cov0" title="0">result, erro := c.CallTool("browser_take_screenshot", map[string]interface{}{
                                        "format": "png",
                                })
                                if erro != nil </span><span class="cov0" title="0">{
                                        log.Printf("Screenshot tool call failed: %v", erro)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚úÖ Screenshot taken successfully!\n")
                                        if result.IsError </span><span class="cov0" title="0">{
                                                fmt.Printf("‚ö†Ô∏è  Screenshot tool returned an error\n")
                                        }</span>
                                        <span class="cov0" title="0">if len(result.Content) &gt; 0 </span><span class="cov0" title="0">{
                                                allContent := result.GetAllContent()

                                                for _, content := range allContent </span><span class="cov0" title="0">{
                                                        fmt.Printf("üìÑ Content type: %s\n", content.ContentType())
                                                        switch content.ContentType() </span>{
                                                        case "text":<span class="cov0" title="0">
                                                                textContents := result.GetTextContent()
                                                                if len(textContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        fmt.Printf("üìÑ Tool output: %s\n", textContents[0].Text)
                                                                }</span>
                                                        case "image":<span class="cov0" title="0">
                                                                imageContents := result.GetImageContent()
                                                                if len(imageContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        for _, img := range imageContents </span><span class="cov0" title="0">{
                                                                                fmt.Printf("üì∏ Screenshot captured (image data available, type: %s)\n", img.MimeType)
                                                                        }</span>
                                                                }
                                                        default:<span class="cov0" title="0">
                                                                fmt.Printf("üìÑ Tool output available (%d items)\n", len(result.Content))</span>
                                                        }
                                                }
                                        }
                                }

                                <span class="cov0" title="0">result, err = c.CallTool("browser_snapshot", map[string]interface{}{})
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Snapshot tool call failed: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚úÖ Snapshot taken successfully!\n")
                                        if result.IsError </span><span class="cov0" title="0">{
                                                fmt.Printf("‚ö†Ô∏è  Snapshot tool returned an error\n")
                                        }</span>
                                        <span class="cov0" title="0">if len(result.Content) &gt; 0 </span><span class="cov0" title="0">{
                                                allContent := result.GetAllContent()

                                                for _, content := range allContent </span><span class="cov0" title="0">{
                                                        fmt.Printf("üìÑ Content type: %s\n", content.ContentType())
                                                        switch content.ContentType() </span>{
                                                        case "text":<span class="cov0" title="0">
                                                                textContents := result.GetTextContent()
                                                                if len(textContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        fmt.Printf("üìÑ Tool output: %s\n", textContents[0].Text)
                                                                }</span>
                                                        case "image":<span class="cov0" title="0">
                                                                imageContents := result.GetImageContent()
                                                                if len(imageContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        for _, img := range imageContents </span><span class="cov0" title="0">{
                                                                                fmt.Printf("üì∏ Snapshot captured (image data available, type: %s)\n", img.MimeType)
                                                                        }</span>
                                                                }
                                                        default:<span class="cov0" title="0">
                                                                fmt.Printf("üìÑ Tool output available (%d items)\n", len(result.Content))</span>
                                                        }
                                                }
                                        }
                                }

                                <span class="cov0" title="0">result, err = c.CallTool("browser_click", map[string]interface{}{
                                        "element": "link",
                                        "ref":     "e107",
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Click tool call failed: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚úÖ Click action performed successfully!\n")
                                        if result.IsError </span><span class="cov0" title="0">{
                                                fmt.Printf("‚ö†Ô∏è  Click tool returned an error\n")
                                        }</span>
                                        <span class="cov0" title="0">if len(result.Content) &gt; 0 </span><span class="cov0" title="0">{
                                                allContent := result.GetAllContent()

                                                for _, content := range allContent </span><span class="cov0" title="0">{
                                                        fmt.Printf("üìÑ Content type: %s\n", content.ContentType())
                                                        switch content.ContentType() </span>{
                                                        case "text":<span class="cov0" title="0">
                                                                textContents := result.GetTextContent()
                                                                if len(textContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        fmt.Printf("üìÑ Tool output: %s\n", textContents[0].Text)
                                                                }</span>
                                                        case "image":<span class="cov0" title="0">
                                                                imageContents := result.GetImageContent()
                                                                if len(imageContents) &gt; 0 </span><span class="cov0" title="0">{
                                                                        for _, img := range imageContents </span><span class="cov0" title="0">{
                                                                                fmt.Printf("üì∏ Click action captured (image data available, type: %s)\n", img.MimeType)
                                                                        }</span>
                                                                }
                                                        default:<span class="cov0" title="0">
                                                                fmt.Printf("üìÑ Tool output available (%d items)\n", len(result.Content))</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        // List resources if available
        <span class="cov0" title="0">if c.HasResources() </span><span class="cov0" title="0">{
                fmt.Println("\nüìÅ Listing resources...")
                resources, err := c.ListResources()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to list resources: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Found %d resources:\n", len(resources))
                        for i, resource := range resources </span><span class="cov0" title="0">{
                                fmt.Printf("   %d. %s (%s)\n", i+1, resource.Name, resource.URI)
                        }</span>
                }
        }

        // List prompts if available
        <span class="cov0" title="0">if c.HasPrompts() </span><span class="cov0" title="0">{
                fmt.Println("\nüí¨ Listing prompts...")
                prompts, err := c.ListPrompts()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to list prompts: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Found %d prompts:\n", len(prompts))
                        for i, prompt := range prompts </span><span class="cov0" title="0">{
                                fmt.Printf("   %d. %s - %s\n", i+1, prompt.Name, prompt.Description)
                        }</span>
                }
        }

        // Clean up
        <span class="cov0" title="0">err = c.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to close client: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nüèÅ Example completed successfully!")
        fmt.Println("Your professional MCP Go client library is working! üéâ")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"

        "github.com/ybbus/jsonrpc/v3"
)

// SessionAwareHTTPClient wraps the standard HTTP client to handle sessions and SSE responses
type SessionAwareHTTPClient struct {
        *http.Client
        sessionID string
}

func (c *SessionAwareHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // Add session ID header if we have one
        if c.sessionID != "" </span><span class="cov0" title="0">{
                req.Header.Set("Mcp-Session-Id", c.sessionID)
        }</span>

        <span class="cov0" title="0">resp, err := c.Client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        // Extract session ID from first response
        <span class="cov0" title="0">if c.sessionID == "" &amp;&amp; resp.Header.Get("Mcp-Session-Id") != "" </span><span class="cov0" title="0">{
                c.sessionID = resp.Header.Get("Mcp-Session-Id")
                fmt.Printf("üîê Session ID established: %s\n", c.sessionID)
        }</span>

        // Convert SSE format to regular JSON if needed
        <span class="cov0" title="0">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, err
                }</span>
                <span class="cov0" title="0">resp.Body.Close()

                bodyStr := string(body)

                // Handle different SSE formats
                if strings.Contains(bodyStr, "data: ") </span><span class="cov0" title="0">{
                        // Extract JSON from SSE format
                        lines := strings.Split(bodyStr, "\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                line = strings.TrimSpace(line)
                                if strings.HasPrefix(line, "data: ") </span><span class="cov0" title="0">{
                                        jsonData := strings.TrimPrefix(line, "data: ")
                                        if jsonData != "" &amp;&amp; jsonData != "[DONE]" </span><span class="cov0" title="0">{
                                                resp.Body = io.NopCloser(strings.NewReader(jsonData))
                                                resp.ContentLength = int64(len(jsonData))
                                                break</span>
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> {
                        resp.Body = io.NopCloser(bytes.NewReader(body))
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func main() <span class="cov0" title="0">{
        fmt.Println("üé≠ Real Playwright MCP Client - HTTP Edition")
        fmt.Println("Connecting to your HTTP MCP server at localhost:9831...")
        fmt.Println()

        // Create session-aware HTTP client
        httpClient := &amp;SessionAwareHTTPClient{Client: &amp;http.Client{}}

        // Create JSON-RPC client with SSE support
        client := jsonrpc.NewClientWithOpts("http://localhost:9831/mcp", &amp;jsonrpc.RPCClientOpts{
                HTTPClient: httpClient,
                CustomHeaders: map[string]string{
                        "Accept": "application/json, text/event-stream",
                },
        })

        ctx := context.Background()

        fmt.Println("üöÄ Step 1: Initialize connection...")

        // Initialize the connection
        var initResult map[string]interface{}
        err := client.CallFor(ctx, &amp;initResult, "initialize", map[string]interface{}{
                "protocolVersion": "2024-11-05",
                "capabilities":    map[string]interface{}{},
                "clientInfo": map[string]interface{}{
                        "name":    "http-playwright-client",
                        "version": "1.0.0",
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Initialize failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Successfully connected!\n")

        // Extract and display server info
        if serverInfo, ok := initResult["serverInfo"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if name, ok := serverInfo["name"].(string); ok </span><span class="cov0" title="0">{
                        fmt.Printf("üì° Server: %s", name)
                        if version, ok := serverInfo["version"].(string); ok </span><span class="cov0" title="0">{
                                fmt.Printf(" v%s", version)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        // Extract and display capabilities
        <span class="cov0" title="0">if capabilities, ok := initResult["capabilities"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                fmt.Printf("üîß Server capabilities:\n")
                if _, exists := capabilities["tools"]; exists </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚úÖ Tools: Available\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ùå Tools: Not available\n")
                }</span>
                <span class="cov0" title="0">if _, exists := capabilities["resources"]; exists </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚úÖ Resources: Available\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ùå Resources: Not available\n")
                }</span>
                <span class="cov0" title="0">if _, exists := capabilities["prompts"]; exists </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚úÖ Prompts: Available\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   ‚ùå Prompts: Not available\n")
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\nüîß Step 2: List available tools...")

        // List available tools
        var toolsResult map[string]interface{}
        err = client.CallFor(ctx, &amp;toolsResult, "tools/list")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Tools listing failed: %v\n", err)
                fmt.Println("\nüîç Analysis: Server requires persistent session state")
                fmt.Println("   ‚Ä¢ Each HTTP request is treated as a new session")
                fmt.Println("   ‚Ä¢ Initialization state is not preserved across requests")
                fmt.Println("   ‚Ä¢ This is a server implementation limitation")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ Tools listing succeeded!\n")
                displayTools(toolsResult)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nüîß Step 3: Try taking a screenshot...")

        // Try calling a real tool - browser_take_screenshot
        var screenshotResult map[string]interface{}
        err = client.CallFor(ctx, &amp;screenshotResult, "tools/call", map[string]interface{}{
                "name": "browser_navigate",
                "arguments": map[string]interface{}{
                        "url": "https://httpbin.org/get",
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Navigation failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úÖ Successfully navigated!\n")
                log.Println(fmt.Sprintf("screenshotResult: %+v", screenshotResult))
                if content, ok := screenshotResult["content"].([]interface{}); ok &amp;&amp; len(content) &gt; 0 </span><span class="cov0" title="0">{
                        if textContent, ok := content[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if text, ok := textContent["text"].(string); ok </span><span class="cov0" title="0">{
                                        fmt.Printf("üìÑ Response: %s\n", text[:min(200, len(text))]+"...")
                                }</span>
                        }
                }

                // Now try to take a screenshot
                <span class="cov0" title="0">var ssResult map[string]interface{}
                err = client.CallFor(ctx, &amp;ssResult, "tools/call", map[string]interface{}{
                        "name":      "browser_take_screenshot",
                        "arguments": map[string]interface{}{},
                })

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("‚ùå Screenshot failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚úÖ Screenshot taken successfully!\n")
                        if content, ok := ssResult["content"].([]interface{}); ok &amp;&amp; len(content) &gt; 0 </span><span class="cov0" title="0">{
                                if imageContent, ok := content[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if imageType, ok := imageContent["type"].(string); ok &amp;&amp; imageType == "image" </span><span class="cov0" title="0">{
                                                fmt.Printf("üì∏ Screenshot captured (image data available)\n")
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">fmt.Println("\nüí° What we've accomplished:")
        fmt.Println("   ‚úÖ Successfully connected to your HTTP MCP server")
        fmt.Println("   ‚úÖ Handled Server-Sent Events (SSE) response format")
        fmt.Println("   ‚úÖ Retrieved server information and capabilities")
        fmt.Println("   ‚úÖ Successfully listed all available tools")
        fmt.Println("   ‚úÖ Proper session management with Mcp-Session-Id header")
        fmt.Println("   ‚úÖ Real tool calling with browser automation")

        fmt.Println("\nüéØ Available Playwright Tools:")
        fmt.Println("   ‚Ä¢ browser_navigate - Navigate to URLs")
        fmt.Println("   ‚Ä¢ browser_take_screenshot - Capture page screenshots")
        fmt.Println("   ‚Ä¢ browser_snapshot - Get accessibility snapshot")
        fmt.Println("   ‚Ä¢ browser_click - Click elements")
        fmt.Println("   ‚Ä¢ browser_type - Type text into inputs")
        fmt.Println("   ‚Ä¢ browser_evaluate - Run JavaScript")
        fmt.Println("   ‚Ä¢ And 18 more tools for complete browser automation!")

        // Demo what the tools would look like and how to call them
        demonstratePlaywrightTools()

        fmt.Println("\nüèÅ Summary:")
        fmt.Println("   ‚Ä¢ Your Go MCP client library works perfectly")
        fmt.Println("   ‚Ä¢ HTTP transport with full session support is functional")
        fmt.Println("   ‚Ä¢ Tool listing and calling works with proper session management")
        fmt.Println("   ‚Ä¢ Ready for production use with Playwright MCP server!")</span>
}

func displayTools(result map[string]interface{}) <span class="cov0" title="0">{
        if tools, ok := result["tools"].([]interface{}); ok </span><span class="cov0" title="0">{
                fmt.Printf("üìã Found %d tools:\n", len(tools))
                for i, tool := range tools </span><span class="cov0" title="0">{
                        if toolMap, ok := tool.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if name, ok := toolMap["name"].(string); ok </span><span class="cov0" title="0">{
                                        fmt.Printf("   %d. %s\n", i+1, name)
                                        if desc, ok := toolMap["description"].(string); ok </span><span class="cov0" title="0">{
                                                fmt.Printf("      üìù %s\n", desc)
                                        }</span>
                                }
                        }
                }
        }
}

func demonstratePlaywrightTools() <span class="cov0" title="0">{
        fmt.Println("\nüé¨ Example: Taking a screenshot")
        fmt.Println("   Tool: screenshot")
        fmt.Println("   URL: https://example.com")
        fmt.Println("   Parameters: {\"url\": \"https://example.com\", \"width\": 1280, \"height\": 720}")

        fmt.Println("\nüñ±Ô∏è  Example: Clicking an element")
        fmt.Println("   Tool: click_element")
        fmt.Println("   Parameters: {\"selector\": \"button.submit\"}")

        fmt.Println("\nüìù Example: Filling a form")
        fmt.Println("   Tool: fill_form")
        fmt.Println("   Parameters: {\"selector\": \"input[name=email]\", \"value\": \"test@example.com\"}")

        fmt.Println("\nüíª JSON-RPC call format:")
        fmt.Println("   {")
        fmt.Println("     \"jsonrpc\": \"2.0\",")
        fmt.Println("     \"id\": 1,")
        fmt.Println("     \"method\": \"tools/call\",")
        fmt.Println("     \"params\": {")
        fmt.Println("       \"name\": \"screenshot\",")
        fmt.Println("       \"arguments\": {")
        fmt.Println("         \"url\": \"https://example.com\",")
        fmt.Println("         \"width\": 1280,")
        fmt.Println("         \"height\": 720")
        fmt.Println("       }")
        fmt.Println("     }")
        fmt.Println("   }")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package http implements MCP over HTTP transport
package http

import (
        "context"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/ybbus/jsonrpc/v3"
)

// SessionAwareHTTPClient is an HTTP client that handles MCP session management
type SessionAwareHTTPClient struct {
        client    *http.Client
        sessionID string
}

// NewSessionAwareHTTPClient creates a new session-aware HTTP client
func NewSessionAwareHTTPClient(timeout time.Duration) *SessionAwareHTTPClient <span class="cov7" title="11">{
        return &amp;SessionAwareHTTPClient{
                client: &amp;http.Client{
                        Timeout: timeout,
                },
        }
}</span>

// Do performs an HTTP request with session management
func (s *SessionAwareHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov5" title="5">{
        // Add session ID if we have one
        if s.sessionID != "" </span><span class="cov1" title="1">{
                req.Header.Set("Mcp-Session-Id", s.sessionID)
        }</span>

        <span class="cov5" title="5">resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Extract session ID from response
        <span class="cov5" title="5">if sessionID := resp.Header.Get("Mcp-Session-Id"); sessionID != "" </span><span class="cov2" title="2">{
                s.sessionID = sessionID
        }</span>

        // Handle Server-Sent Events format
        <span class="cov5" title="5">if strings.Contains(resp.Header.Get("Content-Type"), "text/event-stream") </span><span class="cov1" title="1">{
                body, err := s.parseSSEResponse(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        return nil, err
                }</span>
                <span class="cov1" title="1">resp.Body = body</span>
        }

        <span class="cov5" title="5">return resp, nil</span>
}

// GetSessionID returns the current session ID
func (s *SessionAwareHTTPClient) GetSessionID() string <span class="cov4" title="3">{
        return s.sessionID
}</span>

// parseSSEResponse parses Server-Sent Events format and extracts JSON data
func (s *SessionAwareHTTPClient) parseSSEResponse(body io.ReadCloser) (io.ReadCloser, error) <span class="cov5" title="5">{
        defer body.Close()

        data, err := io.ReadAll(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="5">lines := strings.Split(string(data), "\n")
        var jsonData strings.Builder

        for _, line := range lines </span><span class="cov10" title="25">{
                line = strings.TrimSpace(line)
                if strings.HasPrefix(line, "data: ") </span><span class="cov6" title="8">{
                        jsonLine := strings.TrimPrefix(line, "data: ")
                        if jsonLine != "" &amp;&amp; jsonLine != "[DONE]" </span><span class="cov6" title="6">{
                                jsonData.WriteString(jsonLine)
                        }</span>
                }
        }

        <span class="cov5" title="5">return io.NopCloser(strings.NewReader(jsonData.String())), nil</span>
}

// Config represents transport configuration
type Config struct {
        ServerURL     string
        Timeout       time.Duration
        CustomHeaders map[string]string
}

// Option defines a function that configures the transport
type Option func(*Config)

// WithTimeout sets the transport timeout
func WithTimeout(timeout time.Duration) Option <span class="cov2" title="2">{
        return func(c *Config) </span><span class="cov2" title="2">{
                c.Timeout = timeout
        }</span>
}

// WithCustomHeaders sets custom HTTP headers
func WithCustomHeaders(headers map[string]string) Option <span class="cov2" title="2">{
        return func(c *Config) </span><span class="cov2" title="2">{
                c.CustomHeaders = headers
        }</span>
}

// WithHeader adds a single custom HTTP header
func WithHeader(key, value string) Option <span class="cov4" title="4">{
        return func(c *Config) </span><span class="cov4" title="4">{
                if c.CustomHeaders == nil </span><span class="cov0" title="0">{
                        c.CustomHeaders = make(map[string]string)
                }</span>
                <span class="cov4" title="4">c.CustomHeaders[key] = value</span>
        }
}

// WithSSESupport is a convenience option that adds SSE headers
func WithSSESupport() Option <span class="cov2" title="2">{
        return WithHeader("Accept", "application/json, text/event-stream")
}</span>

// defaultConfig returns a default transport configuration
func defaultConfig() *Config <span class="cov7" title="12">{
        return &amp;Config{
                Timeout: 30 * time.Second,
                CustomHeaders: map[string]string{
                        "Accept": "application/json, text/event-stream",
                },
        }
}</span>

// HTTPTransport implements MCP over HTTP
type HTTPTransport struct {
        config Config
        client jsonrpc.RPCClient
        http   *SessionAwareHTTPClient
}

// NewHTTPTransport creates a new HTTP transport with options
func NewHTTPTransport(serverURL string, opts ...Option) *HTTPTransport <span class="cov6" title="7">{
        config := defaultConfig()
        config.ServerURL = serverURL

        // Apply all options
        for _, opt := range opts </span><span class="cov4" title="4">{
                opt(config)
        }</span>

        <span class="cov6" title="7">httpClient := NewSessionAwareHTTPClient(config.Timeout)

        // Create JSON-RPC client with session-aware HTTP client
        rpcClient := jsonrpc.NewClientWithOpts(config.ServerURL, &amp;jsonrpc.RPCClientOpts{
                HTTPClient: httpClient,
                CustomHeaders: func() map[string]string </span><span class="cov6" title="7">{
                        headers := map[string]string{
                                "Accept": "application/json, text/event-stream",
                        }
                        // Add custom headers
                        for k, v := range config.CustomHeaders </span><span class="cov7" title="9">{
                                headers[k] = v
                        }</span>
                        <span class="cov6" title="7">return headers</span>
                }(),
        })

        <span class="cov6" title="7">return &amp;HTTPTransport{
                config: *config,
                client: rpcClient,
                http:   httpClient,
        }</span>
}

// NewHTTPTransportWithConfig creates a new HTTP transport with config (legacy)
// Deprecated: Use NewHTTPTransport with options instead
func NewHTTPTransportWithConfig(config Config) *HTTPTransport <span class="cov1" title="1">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov1" title="1">httpClient := NewSessionAwareHTTPClient(config.Timeout)

        // Create JSON-RPC client with session-aware HTTP client
        rpcClient := jsonrpc.NewClientWithOpts(config.ServerURL, &amp;jsonrpc.RPCClientOpts{
                HTTPClient: httpClient,
                CustomHeaders: func() map[string]string </span><span class="cov1" title="1">{
                        headers := map[string]string{
                                "Accept": "application/json, text/event-stream",
                        }
                        // Add custom headers
                        for k, v := range config.CustomHeaders </span><span class="cov1" title="1">{
                                headers[k] = v
                        }</span>
                        <span class="cov1" title="1">return headers</span>
                }(),
        })

        <span class="cov1" title="1">return &amp;HTTPTransport{
                config: config,
                client: rpcClient,
                http:   httpClient,
        }</span>
}

// Call makes a JSON-RPC call
func (t *HTTPTransport) Call(ctx context.Context, result interface{}, method string, params ...interface{}) error <span class="cov2" title="2">{
        if len(params) == 0 </span><span class="cov1" title="1">{
                return t.client.CallFor(ctx, result, method)
        }</span>
        <span class="cov1" title="1">return t.client.CallFor(ctx, result, method, params[0])</span>
}

// CallRaw makes a JSON-RPC call and returns the raw response
func (t *HTTPTransport) CallRaw(ctx context.Context, method string, params interface{}) (map[string]interface{}, error) <span class="cov1" title="1">{
        var result map[string]interface{}
        err := t.Call(ctx, &amp;result, method, params)
        return result, err
}</span>

// GetSessionID returns the current session ID
func (t *HTTPTransport) GetSessionID() string <span class="cov1" title="1">{
        return t.http.GetSessionID()
}</span>

// Close closes the transport (no-op for HTTP)
func (t *HTTPTransport) Close() error <span class="cov6" title="8">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package stdio implements MCP over stdio transport
package stdio

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "sync"
        "sync/atomic"
        "time"

        "github.com/ybbus/jsonrpc/v3"
)

// Transport implements MCP over stdio (standard input/output)
type Transport struct {
        cmd       *exec.Cmd
        stdin     io.WriteCloser
        stdout    io.ReadCloser
        stderr    io.ReadCloser
        scanner   *bufio.Scanner
        mu        sync.RWMutex
        sessionID string
        nextID    int64
        closed    bool

        // For handling concurrent requests
        pendingRequests map[int64]chan *jsonrpc.RPCResponse
        requestsMu      sync.RWMutex

        // For handling notifications and server requests
        notificationHandler func(method string, params interface{})
        requestHandler      func(method string, params interface{}) (interface{}, error)

        // Background reader control
        stopReader chan struct{}
        readerDone chan struct{}
}

// Config holds configuration for stdio transport
type Config struct {
        Command    string        // Command to execute
        Args       []string      // Command arguments
        WorkingDir string        // Working directory for the command
        Env        []string      // Environment variables
        Timeout    time.Duration // Request timeout
}

// Option defines a function that configures the stdio transport
type Option func(*Config)

// WithCommand sets the command to execute
func WithCommand(command string) Option <span class="cov0" title="0">{
        return func(c *Config) </span><span class="cov0" title="0">{
                c.Command = command
        }</span>
}

// WithArgs sets the command arguments
func WithArgs(args ...string) Option <span class="cov0" title="0">{
        return func(c *Config) </span><span class="cov0" title="0">{
                c.Args = args
        }</span>
}

// WithWorkingDir sets the working directory
func WithWorkingDir(dir string) Option <span class="cov3" title="2">{
        return func(c *Config) </span><span class="cov3" title="2">{
                c.WorkingDir = dir
        }</span>
}

// WithEnv sets environment variables
func WithEnv(env []string) Option <span class="cov3" title="2">{
        return func(c *Config) </span><span class="cov3" title="2">{
                c.Env = env
        }</span>
}

// WithTimeout sets the request timeout
func WithTimeout(timeout time.Duration) Option <span class="cov3" title="2">{
        return func(c *Config) </span><span class="cov3" title="2">{
                c.Timeout = timeout
        }</span>
}

// defaultConfig returns a default stdio configuration
func defaultConfig() *Config <span class="cov10" title="15">{
        return &amp;Config{
                Command: "",
                Args:    []string{},
                Env:     os.Environ(),
                Timeout: 30 * time.Second,
        }
}</span>

// NewTransport creates a new stdio transport with options
func NewTransport(command string, args []string, opts ...Option) (*Transport, error) <span class="cov9" title="14">{
        config := defaultConfig()
        config.Command = command
        config.Args = args

        // Apply all options
        for _, opt := range opts </span><span class="cov4" title="3">{
                opt(config)
        }</span>

        <span class="cov9" title="14">return NewTransportWithConfig(*config)</span>
}

// NewTransportFromStreams creates a stdio transport using existing streams
// This is useful when your program IS the MCP server and wants to communicate
// over its own stdin/stdout, or when you have custom streams
func NewTransportFromStreams(stdin io.WriteCloser, stdout io.ReadCloser, stderr io.ReadCloser) (*Transport, error) <span class="cov1" title="1">{
        transport := &amp;Transport{
                cmd:             nil, // No subprocess when using existing streams
                stdin:           stdin,
                stdout:          stdout,
                stderr:          stderr,
                scanner:         bufio.NewScanner(stdout),
                nextID:          1,
                pendingRequests: make(map[int64]chan *jsonrpc.RPCResponse),
                stopReader:      make(chan struct{}),
                readerDone:      make(chan struct{}),
        }

        // Start reading stderr in background (if provided)
        if stderr != nil </span><span class="cov1" title="1">{
                go transport.readStderr()
        }</span>

        // Start reading stdout in background
        <span class="cov1" title="1">go transport.readMessages()

        return transport, nil</span>
}

// NewTransportFromOS creates a stdio transport using the current process's stdin/stdout
// This is useful when your Go program IS an MCP server
func NewTransportFromOS() (*Transport, error) <span class="cov1" title="1">{
        // Note: We don't close os.Stdin/Stdout in this case since they're owned by the OS
        return NewTransportFromStreams(
                &amp;nopCloser{os.Stdin},  // Wrap to prevent closing
                &amp;nopCloser{os.Stdout}, // Wrap to prevent closing
                &amp;nopCloser{os.Stderr}, // Wrap to prevent closing
        )
}</span>

// nopCloser wraps a ReadWriteCloser but makes Close() a no-op
type nopCloser struct {
        io.ReadWriter
}

func (nc *nopCloser) Close() error <span class="cov4" title="3">{
        return nil // Don't actually close os.Stdin/Stdout/Stderr
}</span>

// NewTransportWithConfig creates a new stdio transport with config
func NewTransportWithConfig(config Config) (*Transport, error) <span class="cov9" title="14">{
        if config.Command == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("command is required for stdio transport")
        }</span>

        // Create the command
        <span class="cov9" title="13">cmd := exec.Command(config.Command, config.Args...)
        if config.WorkingDir != "" </span><span class="cov1" title="1">{
                cmd.Dir = config.WorkingDir
        }</span>
        <span class="cov9" title="13">if len(config.Env) &gt; 0 </span><span class="cov9" title="13">{
                cmd.Env = config.Env
        }</span>

        // Set up pipes
        <span class="cov9" title="13">stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov9" title="13">stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov9" title="13">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                stdin.Close()
                stdout.Close()
                return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        // Start the command
        <span class="cov9" title="13">if err := cmd.Start(); err != nil </span><span class="cov1" title="1">{
                stdin.Close()
                stdout.Close()
                stderr.Close()
                return nil, fmt.Errorf("failed to start command: %w", err)
        }</span>

        <span class="cov9" title="12">transport := &amp;Transport{
                cmd:             cmd,
                stdin:           stdin,
                stdout:          stdout,
                stderr:          stderr,
                scanner:         bufio.NewScanner(stdout),
                nextID:          1,
                pendingRequests: make(map[int64]chan *jsonrpc.RPCResponse),
                stopReader:      make(chan struct{}),
                readerDone:      make(chan struct{}),
        }

        // Start reading stderr in background
        go transport.readStderr()

        // Start reading stdout in background
        go transport.readMessages()

        return transport, nil</span>
}

// readMessages reads and processes JSON-RPC messages from stdout
func (t *Transport) readMessages() <span class="cov9" title="13">{
        defer close(t.readerDone)

        for </span><span class="cov9" title="14">{
                select </span>{
                case &lt;-t.stopReader:<span class="cov8" title="10">
                        return</span>
                default:<span class="cov5" title="4">
                        if !t.scanner.Scan() </span><span class="cov4" title="3">{
                                if err := t.scanner.Err(); err != nil </span><span class="cov3" title="2">{
                                        fmt.Fprintf(os.Stderr, "MCP stdio scanner error: %v\n", err)
                                }</span>
                                <span class="cov4" title="3">return</span>
                        }

                        <span class="cov1" title="1">line := t.scanner.Text()
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">t.processMessage(line)</span>
                }
        }
}

// processMessage processes a single JSON-RPC message
func (t *Transport) processMessage(line string) <span class="cov1" title="1">{
        var message map[string]interface{}
        if err := json.Unmarshal([]byte(line), &amp;message); err != nil </span><span class="cov1" title="1">{
                fmt.Fprintf(os.Stderr, "MCP invalid JSON received: %v\n", err)
                return
        }</span>

        // Check if this is a response (has id and result/error)
        <span class="cov0" title="0">if id, hasID := message["id"]; hasID </span><span class="cov0" title="0">{
                if _, hasResult := message["result"]; hasResult </span><span class="cov0" title="0">{
                        t.handleResponse(message, id)
                        return
                }</span>
                <span class="cov0" title="0">if _, hasError := message["error"]; hasError </span><span class="cov0" title="0">{
                        t.handleResponse(message, id)
                        return
                }</span>

                // This is a request from server
                <span class="cov0" title="0">t.handleServerRequest(message, id)
                return</span>
        }

        // This is a notification
        <span class="cov0" title="0">t.handleNotification(message)</span>
}

// handleResponse handles JSON-RPC responses
func (t *Transport) handleResponse(message map[string]interface{}, id interface{}) <span class="cov0" title="0">{
        idFloat, ok := id.(float64)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">requestID := int64(idFloat)

        t.requestsMu.Lock()
        responseChan, exists := t.pendingRequests[requestID]
        if exists </span><span class="cov0" title="0">{
                delete(t.pendingRequests, requestID)
        }</span>
        <span class="cov0" title="0">t.requestsMu.Unlock()

        if exists </span><span class="cov0" title="0">{
                response := &amp;jsonrpc.RPCResponse{}

                // Handle result
                if result, hasResult := message["result"]; hasResult </span><span class="cov0" title="0">{
                        response.Result = result
                }</span>

                // Handle error
                <span class="cov0" title="0">if errorData, hasError := message["error"]; hasError </span><span class="cov0" title="0">{
                        if errorMap, ok := errorData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                rpcError := &amp;jsonrpc.RPCError{}

                                if code, ok := errorMap["code"].(float64); ok </span><span class="cov0" title="0">{
                                        rpcError.Code = int(code)
                                }</span>
                                <span class="cov0" title="0">if msg, ok := errorMap["message"].(string); ok </span><span class="cov0" title="0">{
                                        rpcError.Message = msg
                                }</span>
                                <span class="cov0" title="0">if data, ok := errorMap["data"]; ok </span><span class="cov0" title="0">{
                                        rpcError.Data = data
                                }</span>

                                <span class="cov0" title="0">response.Error = rpcError</span>
                        }
                }

                <span class="cov0" title="0">select </span>{
                case responseChan &lt;- response:<span class="cov0" title="0"></span>
                case &lt;-time.After(1 * time.Second):<span class="cov0" title="0"></span>
                        // Channel might be closed or blocking
                }
        }
}

// handleServerRequest handles requests from the server
func (t *Transport) handleServerRequest(message map[string]interface{}, id interface{}) <span class="cov3" title="2">{
        method, ok := message["method"].(string)
        if !ok </span><span class="cov0" title="0">{
                t.sendErrorResponse(id, -32600, "Invalid request: missing method")
                return
        }</span>

        <span class="cov3" title="2">params := message["params"]

        if t.requestHandler != nil </span><span class="cov1" title="1">{
                result, err := t.requestHandler(method, params)
                if err != nil </span><span class="cov0" title="0">{
                        t.sendErrorResponse(id, -32000, err.Error())
                }</span> else<span class="cov1" title="1"> {
                        t.sendSuccessResponse(id, result)
                }</span>
        } else<span class="cov1" title="1"> {
                t.sendErrorResponse(id, -32601, "Method not found")
        }</span>
}

// handleNotification handles notifications from the server
func (t *Transport) handleNotification(message map[string]interface{}) <span class="cov3" title="2">{
        method, ok := message["method"].(string)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">params := message["params"]

        if t.notificationHandler != nil </span><span class="cov1" title="1">{
                t.notificationHandler(method, params)
        }</span>
}

// sendErrorResponse sends an error response to the server
func (t *Transport) sendErrorResponse(id interface{}, code int, message string) <span class="cov1" title="1">{
        response := map[string]interface{}{
                "jsonrpc": "2.0",
                "id":      id,
                "error": map[string]interface{}{
                        "code":    code,
                        "message": message,
                },
        }

        t.sendMessage(response)
}</span>

// sendSuccessResponse sends a success response to the server
func (t *Transport) sendSuccessResponse(id interface{}, result interface{}) <span class="cov1" title="1">{
        response := map[string]interface{}{
                "jsonrpc": "2.0",
                "id":      id,
                "result":  result,
        }

        t.sendMessage(response)
}</span>

// sendMessage sends a JSON-RPC message to the server
func (t *Transport) sendMessage(message interface{}) error <span class="cov4" title="3">{
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        <span class="cov4" title="3">t.mu.Lock()
        defer t.mu.Unlock()

        if t.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("transport is closed")
        }</span>

        <span class="cov4" title="3">_, err = t.stdin.Write(append(data, '\n'))
        return err</span>
}

// generateRequestID generates a unique request ID
func (t *Transport) generateRequestID() int64 <span class="cov3" title="2">{
        return atomic.AddInt64(&amp;t.nextID, 1)
}</span>

// SetNotificationHandler sets the handler for server notifications
func (t *Transport) SetNotificationHandler(handler func(method string, params interface{})) <span class="cov1" title="1">{
        t.notificationHandler = handler
}</span>

// SetRequestHandler sets the handler for server requests
func (t *Transport) SetRequestHandler(handler func(method string, params interface{}) (interface{}, error)) <span class="cov1" title="1">{
        t.requestHandler = handler
}</span>

// readStderr reads and logs stderr output
func (t *Transport) readStderr() <span class="cov9" title="13">{
        scanner := bufio.NewScanner(t.stderr)
        for scanner.Scan() </span><span class="cov0" title="0">{
                // Log stderr to help with debugging
                // In production, you might want to use a proper logger
                fmt.Fprintf(os.Stderr, "MCP Server stderr: %s\n", scanner.Text())
        }</span>
}

// Call makes a JSON-RPC call over stdio
func (t *Transport) Call(ctx context.Context, result interface{}, method string, params ...interface{}) error <span class="cov0" title="0">{
        t.mu.RLock()
        if t.closed </span><span class="cov0" title="0">{
                t.mu.RUnlock()
                return fmt.Errorf("transport is closed")
        }</span>
        <span class="cov0" title="0">t.mu.RUnlock()

        // Build the JSON-RPC request
        id := atomic.AddInt64(&amp;t.nextID, 1)
        request := map[string]interface{}{
                "jsonrpc": "2.0",
                "id":      id,
                "method":  method,
        }

        if len(params) &gt; 0 </span><span class="cov0" title="0">{
                request["params"] = params[0]
        }</span>

        // Create response channel
        <span class="cov0" title="0">responseChan := make(chan *jsonrpc.RPCResponse, 1)

        t.requestsMu.Lock()
        t.pendingRequests[id] = responseChan
        t.requestsMu.Unlock()

        // Cleanup on function exit
        defer func() </span><span class="cov0" title="0">{
                t.requestsMu.Lock()
                delete(t.pendingRequests, id)
                t.requestsMu.Unlock()
                close(responseChan)
        }</span>()

        // Send the request
        <span class="cov0" title="0">if err := t.sendMessage(request); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send request: %w", err)
        }</span>

        // Wait for response or context cancellation
        <span class="cov0" title="0">select </span>{
        case response := &lt;-responseChan:<span class="cov0" title="0">
                if response.Error != nil </span><span class="cov0" title="0">{
                        return response.Error
                }</span>

                <span class="cov0" title="0">if result != nil &amp;&amp; response.Result != nil </span><span class="cov0" title="0">{
                        resultBytes, err := json.Marshal(response.Result)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal result: %w", err)
                        }</span>

                        <span class="cov0" title="0">if err := json.Unmarshal(resultBytes, result); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unmarshal result: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>

        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("request timeout")</span>
        }
}

// CallRaw makes a JSON-RPC call and returns the raw response
func (t *Transport) CallRaw(ctx context.Context, method string, params interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var result map[string]interface{}
        err := t.Call(ctx, &amp;result, method, params)
        return result, err
}</span>

// GetSessionID returns the current session ID
func (t *Transport) GetSessionID() string <span class="cov1" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.sessionID
}</span>

// Close closes the stdio transport
func (t *Transport) Close() error <span class="cov9" title="14">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if t.closed </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="13">t.closed = true

        // Stop the background message reader
        close(t.stopReader)

        // Close pending requests with error
        t.requestsMu.Lock()
        for id, ch := range t.pendingRequests </span><span class="cov0" title="0">{
                select </span>{
                case ch &lt;- &amp;jsonrpc.RPCResponse{
                        Error: &amp;jsonrpc.RPCError{
                                Code:    -32000,
                                Message: "Transport closed",
                        },
                }:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">delete(t.pendingRequests, id)</span>
        }
        <span class="cov9" title="13">t.requestsMu.Unlock()

        // Close pipes
        if t.stdin != nil </span><span class="cov9" title="13">{
                t.stdin.Close()
        }</span>
        <span class="cov9" title="13">if t.stdout != nil </span><span class="cov9" title="13">{
                t.stdout.Close()
        }</span>
        <span class="cov9" title="13">if t.stderr != nil </span><span class="cov9" title="13">{
                t.stderr.Close()
        }</span>

        // Wait for reader to finish
        <span class="cov9" title="13">select </span>{
        case &lt;-t.readerDone:<span class="cov9" title="13"></span>
        case &lt;-time.After(1 * time.Second):<span class="cov0" title="0"></span>
        }

        // Wait for the command to finish (only if we started a subprocess)
        <span class="cov9" title="13">if t.cmd != nil &amp;&amp; t.cmd.Process != nil </span><span class="cov9" title="12">{
                // Give the process a moment to exit gracefully
                done := make(chan error, 1)
                go func() </span><span class="cov9" title="12">{
                        done &lt;- t.cmd.Wait()
                }</span>()

                <span class="cov9" title="12">select </span>{
                case err := &lt;-done:<span class="cov9" title="12">
                        return err</span>
                case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                        // Force kill if it doesn't exit gracefully
                        if t.cmd.Process != nil </span><span class="cov0" title="0">{
                                t.cmd.Process.Kill()
                                return t.cmd.Wait()
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package types contains all MCP protocol type definitions
package types

import (
        "encoding/json"
)

// Protocol constants
const (
        LatestProtocolVersion = "2025-06-18"
        JSONRPCVersion        = "2.0"
)

// RequestID represents a uniquely identifying ID for a request in JSON-RPC
type RequestID interface{}

// ProgressToken is used to associate progress notifications with the original request
type ProgressToken interface{}

// Cursor represents an opaque token used for pagination
type Cursor string

// Meta provides additional metadata for MCP interactions
type Meta map[string]interface{}

// Base JSON-RPC message types

// JSONRPCMessage represents any valid JSON-RPC object
type JSONRPCMessage interface {
        GetJSONRPCVersion() string
}

// Request represents a base request structure
type Request struct {
        Method string        `json:"method"`
        Params RequestParams `json:"params,omitempty"`
}

// RequestParams contains parameters for requests
type RequestParams struct {
        Meta   Meta                   `json:"_meta,omitempty"`
        Fields map[string]interface{} `json:"-"`
}

// MarshalJSON implements custom JSON marshaling for RequestParams
func (rp RequestParams) MarshalJSON() ([]byte, error) <span class="cov10" title="4">{
        // Start with the fields map
        result := make(map[string]interface{})
        for k, v := range rp.Fields </span><span class="cov8" title="3">{
                result[k] = v
        }</span>

        // Add Meta if present
        <span class="cov10" title="4">if rp.Meta != nil </span><span class="cov5" title="2">{
                result["_meta"] = rp.Meta
        }</span>

        <span class="cov10" title="4">return json.Marshal(result)</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for RequestParams
func (rp *RequestParams) UnmarshalJSON(data []byte) error <span class="cov10" title="4">{
        var temp map[string]interface{}
        if err := json.Unmarshal(data, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract Meta if present
        <span class="cov10" title="4">if meta, ok := temp["_meta"]; ok </span><span class="cov5" title="2">{
                if metaMap, ok := meta.(map[string]interface{}); ok </span><span class="cov5" title="2">{
                        rp.Meta = metaMap
                }</span>
                <span class="cov5" title="2">delete(temp, "_meta")</span>
        }

        // Store remaining fields
        <span class="cov10" title="4">rp.Fields = temp
        return nil</span>
}

// Response represents a base response structure
type Response struct {
        Meta   Meta                   `json:"_meta,omitempty"`
        Result map[string]interface{} `json:"-"`
}

// MarshalJSON implements custom JSON marshaling for Response
func (r Response) MarshalJSON() ([]byte, error) <span class="cov8" title="3">{
        result := make(map[string]interface{})
        for k, v := range r.Result </span><span class="cov5" title="2">{
                result[k] = v
        }</span>

        <span class="cov8" title="3">if r.Meta != nil </span><span class="cov1" title="1">{
                result["_meta"] = r.Meta
        }</span>

        <span class="cov8" title="3">return json.Marshal(result)</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for Response
func (r *Response) UnmarshalJSON(data []byte) error <span class="cov8" title="3">{
        var temp map[string]interface{}
        if err := json.Unmarshal(data, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="3">if meta, ok := temp["_meta"]; ok </span><span class="cov1" title="1">{
                if metaMap, ok := meta.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        r.Meta = metaMap
                }</span>
                <span class="cov1" title="1">delete(temp, "_meta")</span>
        }

        <span class="cov8" title="3">r.Result = temp
        return nil</span>
}

// Notification represents a base notification structure
type Notification struct {
        Method string             `json:"method"`
        Params NotificationParams `json:"params,omitempty"`
}

// NotificationParams contains parameters for notifications
type NotificationParams struct {
        Meta   Meta                   `json:"_meta,omitempty"`
        Fields map[string]interface{} `json:"-"`
}

// MarshalJSON implements custom JSON marshaling for NotificationParams
func (np NotificationParams) MarshalJSON() ([]byte, error) <span class="cov5" title="2">{
        result := make(map[string]interface{})
        for k, v := range np.Fields </span><span class="cov5" title="2">{
                result[k] = v
        }</span>

        <span class="cov5" title="2">if np.Meta != nil </span><span class="cov1" title="1">{
                result["_meta"] = np.Meta
        }</span>

        <span class="cov5" title="2">return json.Marshal(result)</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for NotificationParams
func (np *NotificationParams) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var temp map[string]interface{}
        if err := json.Unmarshal(data, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if meta, ok := temp["_meta"]; ok </span><span class="cov0" title="0">{
                if metaMap, ok := meta.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        np.Meta = metaMap
                }</span>
                <span class="cov0" title="0">delete(temp, "_meta")</span>
        }

        <span class="cov0" title="0">np.Fields = temp
        return nil</span>
}

// Base metadata structure
type BaseMetadata struct {
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
}

// Role represents a role in a conversation
type Role string

const (
        RoleUser      Role = "user"
        RoleAssistant Role = "assistant"
)

// LoggingLevel represents different logging levels
type LoggingLevel string

const (
        LoggingLevelDebug     LoggingLevel = "debug"
        LoggingLevelInfo      LoggingLevel = "info"
        LoggingLevelNotice    LoggingLevel = "notice"
        LoggingLevelWarning   LoggingLevel = "warning"
        LoggingLevelError     LoggingLevel = "error"
        LoggingLevelCritical  LoggingLevel = "critical"
        LoggingLevelAlert     LoggingLevel = "alert"
        LoggingLevelEmergency LoggingLevel = "emergency"
)

// Content types
type ContentType = string

const (
        ContentTypeText         ContentType = "text"
        ContentTypeImage        ContentType = "image"
        ContentTypeAudio        ContentType = "audio"
        ContentTypeResourceLink ContentType = "resource_link"
        ContentTypeResource     ContentType = "resource"
)

// ContentBlock represents different types of content that can be sent
type ContentBlock interface {
        ContentType() string
}

// TextContent represents text content
type TextContent struct {
        Type        string       `json:"type"`
        Text        string       `json:"text"`
        Annotations *Annotations `json:"annotations,omitempty"`
}

// ContentType returns the content type for TextContent
func (tc TextContent) ContentType() string <span class="cov1" title="1">{
        return ContentTypeText
}</span>

// ImageContent represents image content
type ImageContent struct {
        Type        string       `json:"type"`
        Data        string       `json:"data"` // base64 encoded
        MimeType    string       `json:"mimeType"`
        Annotations *Annotations `json:"annotations,omitempty"`
}

// ContentType returns the content type for ImageContent
func (ic ImageContent) ContentType() string <span class="cov1" title="1">{
        return ContentTypeImage
}</span>

// AudioContent represents audio content
type AudioContent struct {
        Type        string       `json:"type"`
        Data        string       `json:"data"` // base64 encoded
        MimeType    string       `json:"mimeType"`
        Annotations *Annotations `json:"annotations,omitempty"`
}

// ContentType returns the content type for AudioContent
func (ac AudioContent) ContentType() string <span class="cov1" title="1">{
        return ContentTypeAudio
}</span>

// ResourceLinkContent represents a link to a resource
type ResourceLinkContent struct {
        Type        string       `json:"type"`
        URI         string       `json:"uri"`
        Name        string       `json:"name,omitempty"`
        Description string       `json:"description,omitempty"`
        MimeType    string       `json:"mimeType,omitempty"`
        Annotations *Annotations `json:"annotations,omitempty"`
}

// ContentType returns the content type for ResourceLinkContent
func (rlc ResourceLinkContent) ContentType() string <span class="cov1" title="1">{
        return ContentTypeResourceLink
}</span>

// ResourceContent represents an embedded resource
type ResourceContent struct {
        Type        string       `json:"type"`
        Resource    *Resource    `json:"resource"`
        Annotations *Annotations `json:"annotations,omitempty"`
}

// ContentType returns the content type for ResourceContent
func (rc ResourceContent) ContentType() string <span class="cov1" title="1">{
        return ContentTypeResource
}</span>

// Capabilities

// ClientCapabilities represents what the client supports
type ClientCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Sampling     *SamplingCapability    `json:"sampling,omitempty"`
        Roots        *RootsCapability       `json:"roots,omitempty"`
}

// ServerCapabilities represents what the server supports
type ServerCapabilities struct {
        Experimental map[string]interface{} `json:"experimental,omitempty"`
        Logging      *LoggingCapability     `json:"logging,omitempty"`
        Prompts      *PromptsCapability     `json:"prompts,omitempty"`
        Resources    *ResourcesCapability   `json:"resources,omitempty"`
        Tools        *ToolsCapability       `json:"tools,omitempty"`
}

// Individual capability structures
type SamplingCapability struct{}
type RootsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}
type LoggingCapability struct{}
type PromptsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}
type ResourcesCapability struct {
        Subscribe   bool `json:"subscribe,omitempty"`
        ListChanged bool `json:"listChanged,omitempty"`
}
type ToolsCapability struct {
        ListChanged bool `json:"listChanged,omitempty"`
}

// Initialize types

// Implementation represents information about the client or server implementation
type Implementation struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// InitializeRequest is sent from client to server to initialize the connection
type InitializeRequest struct {
        Method string `json:"method"`
        Params struct {
                ProtocolVersion string             `json:"protocolVersion"`
                Capabilities    ClientCapabilities `json:"capabilities"`
                ClientInfo      Implementation     `json:"clientInfo"`
        } `json:"params"`
}

// InitializeResult is the server's response to initialization
type InitializeResult struct {
        ProtocolVersion string             `json:"protocolVersion"`
        Capabilities    ServerCapabilities `json:"capabilities"`
        ServerInfo      Implementation     `json:"serverInfo"`
        Instructions    string             `json:"instructions,omitempty"`
}

// InitializedNotification is sent from client to server after initialization
type InitializedNotification struct {
        Method string `json:"method"`
}

// Ping types

// PingRequest is sent to test liveness/heartbeat
type PingRequest struct {
        Method string `json:"method"`
}

// PingResult is the response to a ping
type PingResult struct{}

// Progress types

// ProgressNotification provides updates on long-running operations
type ProgressNotification struct {
        Method string `json:"method"`
        Params struct {
                ProgressToken ProgressToken `json:"progressToken"`
                Progress      int           `json:"progress"`
                Total         *int          `json:"total,omitempty"`
        } `json:"params"`
}

// Pagination types

// PaginatedRequest represents a request that supports pagination
type PaginatedRequest struct {
        Cursor *Cursor `json:"cursor,omitempty"`
}

// PaginatedResult represents a paginated response
type PaginatedResult struct {
        NextCursor *Cursor `json:"nextCursor,omitempty"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package types contains MCP protocol tool definitions
package types

// Tool represents a tool the client can call
type Tool struct {
        BaseMetadata
        Description  string            `json:"description,omitempty"`
        InputSchema  ToolInputSchema   `json:"inputSchema"`
        OutputSchema *ToolOutputSchema `json:"outputSchema,omitempty"`
        Annotations  *ToolAnnotations  `json:"annotations,omitempty"`
        Meta         Meta              `json:"_meta,omitempty"`
}

// ToolInputSchema defines the expected parameters for the tool
type ToolInputSchema struct {
        Type       string                 `json:"type"`
        Properties map[string]interface{} `json:"properties,omitempty"`
        Required   []string               `json:"required,omitempty"`
}

// ToolOutputSchema defines the structure of the tool's output
type ToolOutputSchema struct {
        Type       string                 `json:"type"`
        Properties map[string]interface{} `json:"properties,omitempty"`
        Required   []string               `json:"required,omitempty"`
}

// ToolAnnotations provide additional properties describing a Tool to clients
type ToolAnnotations struct {
        Title           string `json:"title,omitempty"`
        ReadOnlyHint    bool   `json:"readOnlyHint,omitempty"`
        DestructiveHint bool   `json:"destructiveHint,omitempty"`
        IdempotentHint  bool   `json:"idempotentHint,omitempty"`
        OpenWorldHint   bool   `json:"openWorldHint,omitempty"`
}

// Tool request/response types

// ListToolsRequest is sent from the client to request a list of tools
type ListToolsRequest struct {
        Method string `json:"method"`
        Params struct {
                Cursor Cursor `json:"cursor,omitempty"`
        } `json:"params,omitempty"`
}

// ListToolsResult is the server's response to a tools/list request
type ListToolsResult struct {
        Tools      []Tool  `json:"tools"`
        NextCursor *Cursor `json:"nextCursor,omitempty"`
        Meta       Meta    `json:"_meta,omitempty"`
}

// CallToolRequest is sent from the client to invoke a tool
type CallToolRequest struct {
        Method string `json:"method"`
        Params struct {
                Name      string                 `json:"name"`
                Arguments map[string]interface{} `json:"arguments,omitempty"`
                Meta      Meta                   `json:"_meta,omitempty"`
        } `json:"params"`
}

// CallToolResult is the server's response to a tools/call request
type CallToolResult struct {
        Content []interface{} `json:"content"` // Using interface{} for flexible JSON unmarshaling
        IsError bool          `json:"isError,omitempty"`
        Meta    Meta          `json:"_meta,omitempty"`
}

// GetTextContent extracts text content from the result as properly typed TextContent structs
func (ctr *CallToolResult) GetTextContent() []TextContent <span class="cov0" title="0">{
        var texts []TextContent
        for _, content := range ctr.Content </span><span class="cov0" title="0">{
                if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if contentType, ok := contentMap["type"].(string); ok &amp;&amp; contentType == "text" </span><span class="cov0" title="0">{
                                if text, ok := contentMap["text"].(string); ok </span><span class="cov0" title="0">{
                                        textContent := TextContent{
                                                Type: contentType,
                                                Text: text,
                                        }
                                        // Parse annotations if present
                                        if annotations, ok := contentMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                textContent.Annotations = parseAnnotations(annotations)
                                        }</span>
                                        <span class="cov0" title="0">texts = append(texts, textContent)</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return texts</span>
}

// GetTextStrings is a convenience method that returns just the text strings
func (ctr *CallToolResult) GetTextStrings() []string <span class="cov0" title="0">{
        var texts []string
        textContents := ctr.GetTextContent()
        for _, tc := range textContents </span><span class="cov0" title="0">{
                texts = append(texts, tc.Text)
        }</span>
        <span class="cov0" title="0">return texts</span>
}

// GetImageContent extracts image content from the result
func (ctr *CallToolResult) GetImageContent() []ImageContent <span class="cov0" title="0">{
        var images []ImageContent
        for _, content := range ctr.Content </span><span class="cov0" title="0">{
                if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if contentType, ok := contentMap["type"].(string); ok &amp;&amp; contentType == "image" </span><span class="cov0" title="0">{
                                image := ImageContent{Type: contentType}
                                if data, ok := contentMap["data"].(string); ok </span><span class="cov0" title="0">{
                                        image.Data = data
                                }</span>
                                <span class="cov0" title="0">if mimeType, ok := contentMap["mimeType"].(string); ok </span><span class="cov0" title="0">{
                                        image.MimeType = mimeType
                                }</span>
                                // Parse annotations if present
                                <span class="cov0" title="0">if annotations, ok := contentMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        image.Annotations = parseAnnotations(annotations)
                                }</span>
                                <span class="cov0" title="0">images = append(images, image)</span>
                        }
                }
        }
        <span class="cov0" title="0">return images</span>
}

// GetAudioContent extracts audio content from the result
func (ctr *CallToolResult) GetAudioContent() []AudioContent <span class="cov0" title="0">{
        var audios []AudioContent
        for _, content := range ctr.Content </span><span class="cov0" title="0">{
                if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if contentType, ok := contentMap["type"].(string); ok &amp;&amp; contentType == "audio" </span><span class="cov0" title="0">{
                                audio := AudioContent{Type: contentType}
                                if data, ok := contentMap["data"].(string); ok </span><span class="cov0" title="0">{
                                        audio.Data = data
                                }</span>
                                <span class="cov0" title="0">if mimeType, ok := contentMap["mimeType"].(string); ok </span><span class="cov0" title="0">{
                                        audio.MimeType = mimeType
                                }</span>
                                // Parse annotations if present
                                <span class="cov0" title="0">if annotations, ok := contentMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        audio.Annotations = parseAnnotations(annotations)
                                }</span>
                                <span class="cov0" title="0">audios = append(audios, audio)</span>
                        }
                }
        }
        <span class="cov0" title="0">return audios</span>
}

// GetResourceLinkContent extracts resource link content from the result
func (ctr *CallToolResult) GetResourceLinkContent() []ResourceLinkContent <span class="cov0" title="0">{
        var resourceLinks []ResourceLinkContent
        for _, content := range ctr.Content </span><span class="cov0" title="0">{
                if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if contentType, ok := contentMap["type"].(string); ok &amp;&amp; contentType == "resource_link" </span><span class="cov0" title="0">{
                                resourceLink := ResourceLinkContent{Type: contentType}
                                if uri, ok := contentMap["uri"].(string); ok </span><span class="cov0" title="0">{
                                        resourceLink.URI = uri
                                }</span>
                                <span class="cov0" title="0">if name, ok := contentMap["name"].(string); ok </span><span class="cov0" title="0">{
                                        resourceLink.Name = name
                                }</span>
                                <span class="cov0" title="0">if description, ok := contentMap["description"].(string); ok </span><span class="cov0" title="0">{
                                        resourceLink.Description = description
                                }</span>
                                <span class="cov0" title="0">if mimeType, ok := contentMap["mimeType"].(string); ok </span><span class="cov0" title="0">{
                                        resourceLink.MimeType = mimeType
                                }</span>
                                // Parse annotations if present
                                <span class="cov0" title="0">if annotations, ok := contentMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        resourceLink.Annotations = parseAnnotations(annotations)
                                }</span>
                                <span class="cov0" title="0">resourceLinks = append(resourceLinks, resourceLink)</span>
                        }
                }
        }
        <span class="cov0" title="0">return resourceLinks</span>
}

// GetResourceContent extracts embedded resource content from the result
func (ctr *CallToolResult) GetResourceContent() []ResourceContent <span class="cov0" title="0">{
        var resources []ResourceContent
        for _, content := range ctr.Content </span><span class="cov0" title="0">{
                if contentMap, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if contentType, ok := contentMap["type"].(string); ok &amp;&amp; contentType == "resource" </span><span class="cov0" title="0">{
                                resourceContent := ResourceContent{Type: contentType}
                                if resourceData, ok := contentMap["resource"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        resource := parseResource(resourceData)
                                        resourceContent.Resource = &amp;resource
                                }</span>
                                // Parse annotations if present
                                <span class="cov0" title="0">if annotations, ok := contentMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        resourceContent.Annotations = parseAnnotations(annotations)
                                }</span>
                                <span class="cov0" title="0">resources = append(resources, resourceContent)</span>
                        }
                }
        }
        <span class="cov0" title="0">return resources</span>
}

// GetAllContent returns all content items as their proper types
func (ctr *CallToolResult) GetAllContent() []ContentBlock <span class="cov0" title="0">{
        var contents []ContentBlock

        // Add text content
        for _, tc := range ctr.GetTextContent() </span><span class="cov0" title="0">{
                contents = append(contents, tc)
        }</span>

        // Add image content
        <span class="cov0" title="0">for _, ic := range ctr.GetImageContent() </span><span class="cov0" title="0">{
                contents = append(contents, ic)
        }</span>

        // Add audio content
        <span class="cov0" title="0">for _, ac := range ctr.GetAudioContent() </span><span class="cov0" title="0">{
                contents = append(contents, ac)
        }</span>

        // Add resource link content
        <span class="cov0" title="0">for _, rlc := range ctr.GetResourceLinkContent() </span><span class="cov0" title="0">{
                contents = append(contents, rlc)
        }</span>

        // Add resource content
        <span class="cov0" title="0">for _, rc := range ctr.GetResourceContent() </span><span class="cov0" title="0">{
                contents = append(contents, rc)
        }</span>

        <span class="cov0" title="0">return contents</span>
}

// GetContentType returns the type of the first content item
func (ctr *CallToolResult) GetContentType() string <span class="cov0" title="0">{
        if len(ctr.Content) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if contentMap, ok := ctr.Content[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if contentType, ok := contentMap["type"].(string); ok </span><span class="cov0" title="0">{
                        return contentType
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// parseAnnotations converts a map to Annotations struct
func parseAnnotations(annotationMap map[string]interface{}) *Annotations <span class="cov0" title="0">{
        annotations := &amp;Annotations{}

        if audience, ok := annotationMap["audience"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, role := range audience </span><span class="cov0" title="0">{
                        if roleStr, ok := role.(string); ok </span><span class="cov0" title="0">{
                                annotations.Audience = append(annotations.Audience, Role(roleStr))
                        }</span>
                }
        }

        <span class="cov0" title="0">if priority, ok := annotationMap["priority"].(float64); ok </span><span class="cov0" title="0">{
                priorityInt := int(priority)
                annotations.Priority = &amp;priorityInt
        }</span>

        <span class="cov0" title="0">return annotations</span>
}

// parseResource converts a map to Resource struct
func parseResource(resourceMap map[string]interface{}) Resource <span class="cov0" title="0">{
        resource := Resource{}

        if uri, ok := resourceMap["uri"].(string); ok </span><span class="cov0" title="0">{
                resource.URI = uri
        }</span>
        <span class="cov0" title="0">if name, ok := resourceMap["name"].(string); ok </span><span class="cov0" title="0">{
                resource.BaseMetadata.Name = name
        }</span>
        <span class="cov0" title="0">if description, ok := resourceMap["description"].(string); ok </span><span class="cov0" title="0">{
                resource.Description = description
        }</span>
        <span class="cov0" title="0">if mimeType, ok := resourceMap["mimeType"].(string); ok </span><span class="cov0" title="0">{
                resource.MimeType = mimeType
        }</span>
        <span class="cov0" title="0">if size, ok := resourceMap["size"].(float64); ok </span><span class="cov0" title="0">{
                sizeInt := int(size)
                resource.Size = &amp;sizeInt
        }</span>

        // Parse annotations if present
        <span class="cov0" title="0">if annotations, ok := resourceMap["annotations"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                resource.Annotations = parseAnnotations(annotations)
        }</span>

        <span class="cov0" title="0">return resource</span>
}

// ToolsListChangedNotification informs that the list of tools has changed
type ToolsListChangedNotification struct {
        Method string `json:"method"`
        Params struct {
                Meta Meta `json:"_meta,omitempty"`
        } `json:"params,omitempty"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
